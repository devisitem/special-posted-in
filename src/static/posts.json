[
  {
    "path": "/docs/algorithm/heap-sort",
    "header": {
      "layout": "post",
      "title": "Heap sort (힙 정렬) feat.java",
      "categories": [
        "algorithm"
      ],
      "tags": [
        "Java",
        "Algorithm",
        "Sort",
        "Heap Sort",
        "Heap"
      ],
      "date": 1651837980000,
      "profile-image": "/blogging/profile/profile4.jpeg",
      "thumbnail": "/blogging/algorithm/heap/heap_sort_intro.png",
      "current-company": "Herit Corporation",
      "current-position": "Backend Server Developer",
      "summary": "힙과 힙정렬 (우선순위 큐)",
      "expose-images": true,
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "알고리즘"
      ],
      "images": [
        {
          "src": "/blogging/algorithm/heap/tree_images.svg",
          "alt": "위 트리중 어떤것이 힙인지 찾아보세요."
        },
        {
          "src": "/blogging/algorithm/heap/first_iteration.svg",
          "alt": "힙을 만드려면 완전 이진트리가 있어야 해요."
        },
        {
          "src": "/blogging/algorithm/heap/other_iteration.svg",
          "alt": "만약 마지막 내부노드부터 순회할 때, 쵀대힙을 만드려면 위와 같이 만들수 있어요."
        },
        {
          "src": "/blogging/algorithm/heap/last_iteration.svg",
          "alt": "최대힙을 만들어 이런 형태로 노드를 나눌수 있어요."
        },
        {
          "src": "/blogging/algorithm/heap/add_new_17.svg",
          "alt": "만약 다음의 힙에서 17이라는 값이 추가 된다면"
        },
        {
          "src": "/blogging/algorithm/heap/add_new_17_2.svg",
          "alt": "이런식으로 부모노드와 바꿔가며, 다시 힙을 유지할 수 있어요."
        },
        {
          "src": "/blogging/algorithm/heap/heap_sort_1_1.svg",
          "alt": "힙 정렬 1"
        },
        {
          "src": "/blogging/algorithm/heap/heap_sort_1_2.svg",
          "alt": "힙 정렬 2"
        },
        {
          "src": "/blogging/algorithm/heap/heap_sort_1_3.svg",
          "alt": "힙 정렬 3"
        },
        {
          "src": "/blogging/algorithm/heap/heap_sort_1_4.svg",
          "alt": "힙 정렬 4"
        },
        {
          "src": "/blogging/algorithm/heap/heap_sort_1_5.svg",
          "alt": "힙 정렬 5"
        },
        {
          "src": "/blogging/algorithm/heap/heap_sort_1_6.svg",
          "alt": "힙 정렬 6"
        },
        {
          "src": "/blogging/algorithm/heap/heap_sort_1_7.svg",
          "alt": "힙 정렬 7"
        },
        {
          "src": "/blogging/algorithm/heap/heap_sort_1_8.svg",
          "alt": "힙 정렬 8"
        }
      ],
      "headlines": {
        "grade": 0,
        "title": "root",
        "fragmentId": "root",
        "children": [
          {
            "grade": 2,
            "title": "설명",
            "fragmentId": "%EC%84%A4%EB%AA%85",
            "children": [
              {
                "grade": 3,
                "title": "Heap의 속성 (특징)",
                "fragmentId": "heap%EC%9D%98-%EC%86%8D%EC%84%B1-(%ED%8A%B9%EC%A7%95)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "Heap을 만드는 방법",
                "fragmentId": "heap%EC%9D%84-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "Heap이 우선 값을 유지하는 방법",
                "fragmentId": "heap%EC%9D%B4-%EC%9A%B0%EC%84%A0-%EA%B0%92%EC%9D%84-%EC%9C%A0%EC%A7%80%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "Heap을 이용해 정렬을 하는 방법",
                "fragmentId": "heap%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%B4-%EC%A0%95%EB%A0%AC%EC%9D%84-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95",
                "children": [],
                "isSelected": false
              }
            ],
            "isSelected": false
          },
          {
            "grade": 2,
            "title": "구현 코드 (Java)",
            "fragmentId": "%EA%B5%AC%ED%98%84-%EC%BD%94%EB%93%9C-(java)",
            "children": [],
            "isSelected": false
          }
        ],
        "isSelected": false
      }
    },
    "description": "열라 간단한 우선순위 큐의 자료구조인 Heap에 대해 공부합니다.\r\n힙의 속성?! 힙이 최소 또는 최대값을 유지하는 방법?!\r\n\r\n힙을통해 정렬하는 방법까지 공부합니다. 😁\r\n\r\n",
    "content": "\r\n\r\n## 설명\r\n\r\n간단하게 말하여, 힙은 우선순위 큐 입니다. `JAVA`에서는 `PriorityQueue`라는 구현체를 통해 Heap 자료구조를 사용할 수 있어요.\r\n힙은 두 종류가 있는데 `최대 힙`과 `최소 힙`이 있어요. \r\n최대 Heap(최소 Heap)은 단어와 같이 최대 값(최소 값)을 우선순위로 판단하여, 어떠한 값이 들어와도, 항상 같은 순서의\r\n트리를 유지하며, 언제든지 최고 우선순위의 값을 적은 비용으로 쉽게 얻을수 있는 자료구조 입니다.\r\n\r\n### Heap의 속성 (특징)\r\n\r\n* 최대 힙(**또는 최소 힙**)은 `잎(leaf)`의 계층을 제외한 모든 노드는 자식의 노드 보다 큰(**또는 작은**) 값을 가지고 있어야합니다.\r\n* 왼쪽부터 차례대로 채워져있는 `완전 이진 트리(Complete binary tree)`이어야 합니다.\r\n* 같은 계층의 노드들과는 정렬하지 않습니다.\r\n* 루트(뿌리)노드로 부터 내려오는 위치의 노드들 오름차순(**또는 내림차순**)입니다\r\n\r\n![위 트리중 어떤것이 힙인지 찾아보세요.](/blogging/algorithm/heap/tree_images.svg)\r\n\r\n* 트리 A: 잎을 제외한 노드는 모두 정렬되었지만, 왼쪽부터 채워지지않아 Heap이 아닙니다.\r\n* 트리 B: 왼쪽부터 채워졌지만, 2번노드의 값은 그 자식에값보다 작습니다. 따라서 Heap이 아닙니다.\r\n* 트리 C: 잎을 제외한 모든 노드가 자식 또는 부모와 정렬 되어있고, 왼쪽부터 채워져있으므로 `Heap`입니다.\r\n\r\n> 이를 정리하면 아래와 같습니다.   \r\n> 1.`𝑛개`의 노드를 가진 힙은 정확히 하나만 있고 그 힙(트리)의 높이(height)는 `⎣log₂𝑛⎦`이다. 트리의 전체 노드의 개수가 `8`일경우 트리(힙)의 높이는 `3`이다. 즉 힢의 높이는 힙의 성질(속성)에 부합되는 노드들만 인정이 된다는 의미이다.  \r\n> 2.힙의 루트 노드는 항상 최댓값(**또는 최솟값**)을 저장한다. 최대 힙(**또는 최소 힙**)은 쵀댓값(**또는 최솟값**)을 효율적으로 관리하기 위한 자료구조이며, 루트에는 항상 가장 큰(**또는 작은**)값을 유지한다.  \r\n> 3.힙의 한 노드와 그 노드의 자손 노드들로 이루어진 부분 트리(subtree)도 힙이다. 힙은 힙으로 이루어져있으며 자식노드도 힙이 될수있지만, 노드의 자식이없다면 힙이될 수없다. 따라서 위 C 트리의 `4, 5, 6`번 노드는 힙이 아니다.  \r\n:{ \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n### Heap을 만드는 방법\r\n\r\n힙을 구성 하기 위해서는 다음의 순서대로 진행됩니다.\r\n\r\n1. 순회를 시작할 힙이되는 마지막 노드`⎣𝑛/₂⎦`를 찾는다.\r\n2. 마지막 노드 i를 이용해 자식노드가 있는지, 또한 있다면 그 중 자신 보다 큰값을 자신과 찾는다.\r\n3. 찾은 값과 자신을 바꾸고 바꾼 자신의 위치는 그값의 자식이 되며, 자신보다 큰값이 나오지 않을때까지 반복한다.\r\n4. 다음 노드(i -1)에서 다시 `3.`을 반복한다.\r\n\r\n> 자식 노드의 위치를 찾을때는 왼쪽`arr[2i]`값과 오른쪽`arr[2i + 1]`로 구할 수 있습니다.\r\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n\r\n위 의 내용을 정리하면 아래와 같습니다.\r\n\r\n\r\n![힙을 만드려면 완전 이진트리가 있어야 해요.](/blogging/algorithm/heap/first_iteration.svg)\r\n\r\n> 위의 트리는 *완전 이진트리* 입니다. 힙은 완전이진트리에서 만들수 있으므로, 일반 이진트리는 Compact하게 완전이진트리로 바꿔야 힙을 만들수 있습니다.\r\n> 왼쪽 트리의 마지막 힙의 값은 `15` 이며, 이는 자식(`6, 4`) 어느것 보다도 큰값입니다. 따라서 다음 순회로 넘어갑니다.\r\n> 순회는 내부 노드의 마지막 힙의 위치에서 부터 1까지 이어집니다. 따라서 다음 인덱스인 3번 노드(9)로 넘어갑니다.\r\n> 3번노드는 자신의 자식들 중 6번째, 7번째 (7, 12)와 비교하여 더 큰값을 가지는 12와 바꿉니다.\r\n:{ \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n![만약 마지막 내부노드부터 순회할 때, 쵀대힙을 만드려면 위와 같이 만들수 있어요.](/blogging/algorithm/heap/other_iteration.svg)\r\n\r\n> 이후 과정은 위와 같이 반복됩니다. 내부노드를 순회하며 자신의 자식노드가 있는지 확인하고 있다면, 자신과 비교하여 더큰 값으로 바꿉니다. 이는 바꾼이후에도 `3.`이 반복되게 됩니다. 순회되는 노드가 최상위노드가 되고 모든 내부노드가 힙이 될때, 전체 트리는 힙이 됩니다.   \r\n> 마지막까지 바꾼 최종트리는 아래와 같습니다.\r\n:{ \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n![최대힙을 만들어 이런 형태로 노드를 나눌수 있어요.](/blogging/algorithm/heap/last_iteration.svg)\r\n\r\n* 최상위 노드(루트)가 가장 큰값이 되며, 위는 최대힙을 만드는 단계였습니다.\r\n* 부모노드와 자식노드끼리는 순서의 값을 가지며, 항상 최대의 값을 가집니다.  \r\n\r\n### Heap이 우선 값을 유지하는 방법\r\n\r\n위에서는 완전이진트리로 힙을 어떻게 만드는지에 대해 알아봤습니다.\r\n하지만, 힙은 언제나 새로운값이 들어와도 항상 우선 순위로 값을 관리합니다. 만약 저기서 더큰값이 추가된다면,\r\n저 힙트리는 어떻게 바뀔까요? 새로운 값들을 추가해서 힙이 다시 어떻게 유지되는지 배워봅니다.\r\n\r\n#### 값추가\r\n\r\n힙트리에서 값을 추가 할때는 마지막 노드로 붙여주고 위에서 했던것과 동일하게 힙을 만들어 줍니다.\r\n만약 새로운 값 17이 힙에 들어온다면 순서는 아래와 같이 바뀝니다.\r\n\r\n![만약 다음의 힙에서 17이라는 값이 추가 된다면](/blogging/algorithm/heap/add_new_17.svg)\r\n![이런식으로 부모노드와 바꿔가며, 다시 힙을 유지할 수 있어요.](/blogging/algorithm/heap/add_new_17_2.svg)\r\n\r\n\r\n> A: 새로 들어온 값 17은 트리의 맨뒤인 10번노드로 들어갑니다.     \r\n> 또한 마지막 내부노드이자 자신의 부모인 5번 노드(4)부터 다시 순회를 시작하며,  \r\n> 자신보다 큰 값은 가진 자식 10번 노드(17)과 값을 바꿉니다. \r\n> B: 값이 바뀐 10번 노드(4)는 자식을 가지고있지 않으므로 다음 순회로 넘어갑니다.  \r\n> C: 다음 순회인 4번 노드(6)은 자식들보다 큰값이므로 다음 3번 노드(12)로 이동합니다. 하지만 이또한 자식들보다 값이 크므로, 2번 노드(8)로 이동합니다. 자신보다 큰값을 가지는 5번 자식노드(17)과 바꿉니다.  \r\n> D: 값이 바뀐 5번 노드(8)은 자식들 보다 값이 커, 바꿀 필요가 없으므로 다음 순회인 1번 노드(15)로 이동합니다.  \r\n> E: 현재 순회인 1번 노드(15)는 자신의 2번 노드(17)보다 값이 작으므로 바꿉니다.  \r\n> F: 최종적으로 힙이 완성되었습니다.\r\n:{ \"type\": \"tip\", \"icon\": \"check-circle\" }\r\n\r\n\r\n### Heap을 이용해 정렬을 하는 방법\r\n\r\n힙 정렬을 위해서는 사전에 완전 이진 트리를 힙으로 만들고, 정렬을 수행할 수 있습니다.\r\n위에서 만든 힙을 통해 정렬을 하는 방법을 구현합니다.  \r\n힙 정렬은 간단하게, 아래의 정렬하는 순서를 가지고있습니다.\r\n\r\n1. 최상위 노드 `A`와 가장 끝의 노드 `B`를 바꾼다.\r\n2. 바꿔진 A는 맨뒤로 가며,힙에서 제외한다. \r\n3. 바꾼 값 `B`는, 자신의 자식이 있다면, 두개를 비교하여 가장 큰 값과 맞 바꾼다.\r\n4. `3.`의 내용을 힙이될때까지 반복한다.\r\n\r\n위의 순서를 반복하며, 만든 힙 정렬은 아래와 같습니다.\r\n\r\n![힙 정렬 1](/blogging/algorithm/heap/heap_sort_1_1.svg)\r\n![힙 정렬 2](/blogging/algorithm/heap/heap_sort_1_2.svg)\r\n![힙 정렬 3](/blogging/algorithm/heap/heap_sort_1_3.svg)\r\n![힙 정렬 4](/blogging/algorithm/heap/heap_sort_1_4.svg)\r\n![힙 정렬 5](/blogging/algorithm/heap/heap_sort_1_5.svg)\r\n![힙 정렬 6](/blogging/algorithm/heap/heap_sort_1_6.svg)\r\n![힙 정렬 7](/blogging/algorithm/heap/heap_sort_1_7.svg)\r\n![힙 정렬 8](/blogging/algorithm/heap/heap_sort_1_8.svg)\r\n\r\n## 구현 코드 (Java)\r\n\r\n```java\r\nimport java.util.Arrays;\r\n\r\npublic class Heap {\r\n    \r\n    //== 힙(Heap) 을 만드는 메소드 ==//\r\n    public static void makeHeap(int arr[]) {\r\n        // last heap\r\n        int lh = arr.length / 2;\r\n        System.out.println(\"Normal Array = \" + Arrays.toString(arr));\r\n        int eh = arr.length;\r\n        while (lh-- > 0) {\r\n\r\n            System.out.println(\"i: \" + lh);\r\n            pushDown(arr, lh, eh);\r\n        }\r\n\r\n        System.out.println(\"Array as Max Heap = \" + Arrays.toString(arr));\r\n    }\r\n    \r\n    \r\n    //== 노드와 그 자식중에서 더큰(또는 작은) 위치를 찾는 메소드 ==//\r\n    public static int findLargest(int arr[], int node, int eh) {\r\n        // first child\r\n        int fc = (2 * (node + 1)) - 1;\r\n\r\n        if (fc + 1 < eh) {\r\n            if (arr[fc] <= arr[fc + 1]) {\r\n                return arr[fc + 1] <= arr[node] ? node : fc + 1;\r\n            } else {\r\n                return arr[fc] <= arr[node] ? node : fc;\r\n            }\r\n        }\r\n        if (fc < eh && arr[node] < arr[fc]) {\r\n            return fc;\r\n        } else {\r\n            return node;\r\n        }\r\n    }\r\n    //== 값을 아래로 내리는 메소드 ==//\r\n\r\n    /**\r\n     * 간단하게 보면 트리에서 마지막 힙의 위치를 구하고,\r\n     * 루트 노드까지 역순으로 힙을 만들어갑니다.\r\n     * \r\n     * 최대 힙(또는 최소 힙)의 조건에 따라 더큰(또는 더 작은)값을 기준으로,\r\n     * 해당 노드를 위로올리고 변경된 대상은 아래로 내려가며 계속 바꿉니다.\r\n     */\r\n    public static void pushDown(int arr[], int node, int eh) {\r\n        do {\r\n            System.out.println(\"j: \" + node);\r\n            int temp = arr[node];\r\n            int large = findLargest(arr, node, eh);\r\n            System.out.println(drawBinaryTree(arr));\r\n\r\n            if (large == node)\r\n                break;\r\n\r\n            arr[node] = arr[large];\r\n            arr[large] = temp;\r\n\r\n            node = large;\r\n        } while (node <= eh);\r\n    }\r\n\r\n    public static void sort(int arr[]) {\r\n        int last = arr.length;\r\n        makeHeap(arr);\r\n\r\n        while (--last >= 0) {\r\n\r\n            int temp = arr[0];\r\n            arr[0] = arr[last];\r\n            arr[last] = temp;\r\n\r\n            System.out.println(\"last: \" + last);\r\n            pushDown(arr, 0, last);\r\n        }\r\n        ;\r\n    }\r\n\r\n    //== 출력 메소드 ==//\r\n    public static String drawBinaryTree(int arr[]) {\r\n        StringBuilder builder = new StringBuilder();\r\n\r\n        int nol = (int) (Math.log(arr.length) / Math.log(2)) + 1;\r\n        int max = (int) Math.pow(2, nol - 1);\r\n\r\n        int printed = 0;\r\n        for (int i = 0; i < nol; i++) {\r\n            int perFloor = (int) Math.pow(2, i);\r\n            int tab = (max - perFloor) / 2 + (max - perFloor) % 2;\r\n            int last = printed + perFloor;\r\n\r\n            for (int j = 0; j < tab; j++) {\r\n                builder.append(\"  \");\r\n            }\r\n            for (int j = printed; (j < arr.length && j < last); j++) {\r\n                builder.append(String.format(\"(%d)\", arr[j]));\r\n            }\r\n            builder.append(\"\\n\");\r\n            printed += perFloor;\r\n        }\r\n\r\n        return builder.toString();\r\n    }\r\n    \r\n    public static void main(String args []) throws Exception {\r\n        //== 힙 으로 만들기==//\r\n        int arrForMake [] = {1, 5, 8, 2, 74, 9, 12, 104, 87, 43};\r\n        Heap.makeHeap();\r\n        \r\n        //== 힙 + 정렬 ==//\r\n        int arrForSort [] = {1, 8, 9, 15, 4, 7, 12, 6, 4, 17};\r\n        Heap.sort(arr);\r\n        \r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n"
  },
  {
    "path": "/docs/algorithm/selection-sort",
    "header": {
      "layout": "post",
      "title": "-Algorithm- Selection Sort (선택정렬 알고리즘) feat.java",
      "categories": [
        "algorithm"
      ],
      "tags": [
        "Java",
        "Algorithm",
        "Sort",
        "Selection Sort"
      ],
      "date": 1649082840000,
      "thumbnail": "/blogging/algorithm/selection_sort_intro.png",
      "current-company": "Herit Corporation",
      "current-position": "Backend Server Developer",
      "summary": "선택 정렬",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "알고리즘"
      ],
      "images": [],
      "headlines": {
        "grade": 0,
        "title": "root",
        "fragmentId": "root",
        "children": [
          {
            "grade": 2,
            "title": "과정 코드",
            "fragmentId": "%EA%B3%BC%EC%A0%95-%EC%BD%94%EB%93%9C",
            "children": [
              {
                "grade": 3,
                "title": "호출",
                "fragmentId": "%ED%98%B8%EC%B6%9C",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "콘솔",
                "fragmentId": "%EC%BD%98%EC%86%94",
                "children": [],
                "isSelected": false
              }
            ],
            "isSelected": false
          }
        ],
        "isSelected": false
      }
    },
    "description": "기본 정렬 알고리즘중 하나인 선택 정렬(Selection Sort)입니다.\r\n간단한 그림과 함께 쉽게 이해할 수 있도록 정리했어요.\r\n",
    "content": "\r\n\r\n🌸 선택 정렬은 정렬할 배열을 순회하며, 어떤 원소로 대치할지 선택하여 정렬하는 알고리즘 입니다.\r\n설명을 보기에 앞서, 통상적으로 정렬은 오름 또는 내림으로 배열의 수열을 맞추어 순서를 만드는 행위로 의미합니다.\r\n---\r\n\r\n<div class=\"array\">\r\n    <span>1</span>\r\n    <span>4</span>\r\n    <span>7</span>\r\n    <span>3</span>\r\n    <span>2</span>\r\n    <span>5</span>\r\n</div>\r\n\r\n\r\n> 정렬을 하기위해 배열을 준비합니다. 또한, 해당 배열을 순회하면서 *나머지들의 값들중 가장작은 값으로 변경합니다.\r\n:{ \"type\": \"note\", \"icon\": \"info\"}\r\n\r\n순회 인덱스 i: 0\r\n\r\n<div class=\"array\">\r\n    <span class=\"current\">1</span>\r\n    <span>4</span>\r\n    <span>7</span>\r\n    <span>3</span>\r\n    <span>2</span>\r\n    <span>5</span>\r\n</div>\r\n\r\n> 첫번째 순회요소는 나머지의 값들중 가장작은 값인 1 입니다. 따라서, 변경하지않습니다.\r\n:{ \"type\": \"note\", \"icon\": \"info\"}\r\n\r\n순회 인덱스 i: 1\r\n\r\n<div class=\"array\">\r\n    <span class=\"over\">1</span>\r\n    <span class=\"current\">4</span>\r\n    <span>7</span>\r\n    <span>3</span>\r\n    <span class=\"target\">2</span>\r\n    <span>5</span>\r\n</div>\r\n\r\n> 두번째는 4입니다. 나머지의 요소들중 가장작은값이 2가 존재합니다. 4와 2를 변경합니다. 다음 부터는 정렬 순서가 동일합니다. 배열의 끝까지 순회하며 나머지 값들로 선택후 변경으로 정렬합니다.\r\n:{ \"type\": \"note\", \"icon\": \"info\"}\r\n\r\n순회 인덱스 i: 2\r\n\r\n<div class=\"array\">\r\n    <span class=\"over\">1</span>\r\n    <span class=\"over\">2</span>\r\n    <span class=\"current\">7</span>\r\n    <span class=\"target\">3</span>\r\n    <span>4</span>\r\n    <span>5</span>\r\n</div>\r\n\r\n순회 인덱스 i: 3\r\n\r\n<div class=\"array\">\r\n    <span class=\"over\">1</span>\r\n    <span class=\"over\">2</span>\r\n    <span class=\"over\">3</span>\r\n    <span class=\"current\">7</span>\r\n    <span class=\"target\">4</span>\r\n    <span>5</span>\r\n</div>\r\n\r\n순회 인덱스 i: 4\r\n\r\n<div class=\"array\">\r\n    <span class=\"over\">1</span>\r\n    <span class=\"over\">2</span>\r\n    <span class=\"over\">3</span>\r\n    <span class=\"over\">4</span>\r\n    <span class=\"current\">7</span>\r\n    <span class=\"target\">5</span>\r\n</div>\r\n\r\n순회 인덱스 i: 5\r\n\r\n<div class=\"array\">\r\n    <span class=\"over\">1</span>\r\n    <span class=\"over\">2</span>\r\n    <span class=\"over\">3</span>\r\n    <span class=\"over\">4</span>\r\n    <span class=\"over\">5</span>\r\n    <span class=\"over\">7</span>\r\n</div>\r\n\r\n## 과정 코드\r\n\r\n::code-group\r\n\r\n```java [요소 교환]\r\n    /**\r\n     * i 와 j 값 변경\r\n     * 각 인덱스로 접근하므로 시간복잡도는 상수시간을 갖는다. O(1)\r\n     * @param array\r\n     * @param i\r\n     * @param j\r\n     */\r\npublic static void swapElements(int [] array, int i, int j) {\r\n    int temp = array[i];\r\n    array[i] = array[j];\r\n    array[j] = temp;\r\n}\r\n```\r\n\r\n```java [최소값 찾기]\r\n/**\r\n * start 인덱스 부터 시작해서 끝까지 순회중 가장 작은 값을 리턴한다.\r\n * @param array\r\n * @param start\r\n * @return\r\n */\r\npublic static int indexLowest(int [] array, int start) {\r\n    int lowIndex = start;\r\n\r\n    for(int i = start;i < array.length;i++) {\r\n        if(array[i] < array[lowIndex]) {\r\n            lowIndex = i;\r\n        }\r\n    }\r\n    return lowIndex;\r\n}\r\n```\r\n\r\n```java [최소값을 찾고, 변경]\r\n/**\r\n * indexLowest 메서드를 통해 얻어온 가장작은값의 인덱스를 현재 인덱스와 변경한다.\r\n * @param array\r\n */\r\npublic static void selectionSort(int [] array) {\r\n    System.out.printf(\"before selection sort : %s\\n\", Arrays.toString(array));\r\n    for(int i = 0;i < array.length;i++) {\r\n        int j = indexLowest(array, i);\r\n        swapElements(array, i, j);\r\n\r\n        System.out.printf(\"(i = %d) array : %s\\n\",i , Arrays.toString(array));\r\n    }\r\n\r\n}\r\n```\r\n::\r\n\r\n### 호출\r\n\r\n```java\r\nimport sort.selection_sort.SelectionSort;\r\n\r\npublic class Main {\r\n\r\n    public static void main(String[] args) throws Exception {\r\n    \r\n        int [] needSort = {1, 4, 7, 3, 2, 5};\r\n        \r\n        SelectionSort.selectionSort(needSort);\r\n    }\r\n}\r\n```\r\n\r\n### 콘솔\r\n```\r\nbefore selection sort : [1, 4, 7, 3, 2, 5]\r\n(i = 0) array : [1, 4, 7, 3, 2, 5]\r\n(i = 1) array : [1, 2, 7, 3, 4, 5]\r\n(i = 2) array : [1, 2, 3, 7, 4, 5]\r\n(i = 3) array : [1, 2, 3, 4, 7, 5]\r\n(i = 4) array : [1, 2, 3, 4, 5, 7]\r\n(i = 5) array : [1, 2, 3, 4, 5, 7]\r\nafter selection sort : [1, 2, 3, 4, 5, 7]\r\n```\r\n\r\n> 풀이 또는 잘못된 설명은 아래 댓글로 말씀 부탁드립니다.\r\n:{ \"type\": \"note\", \"icon\": \"info\"}\r\n\r\n"
  }
]